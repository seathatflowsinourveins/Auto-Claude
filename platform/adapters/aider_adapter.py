"""
Aider Adapter for Unleashed Platform

Aider is an AI pair programming assistant that works in your terminal.
Key features:
- Direct code editing in your repository
- Git integration with automatic commits
- Multi-model support (Claude, GPT-4, DeepSeek, etc.)
- Architect mode for complex refactoring
- Context-aware code understanding

Repository: https://github.com/Aider-AI/aider
Stars: 35,000+ | License: Apache-2.0

Based on: https://aider.chat/docs/scripting.html
"""

import os
import subprocess
from typing import Any, Dict, List, Optional, Union
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path

# Check Aider availability
AIDER_AVAILABLE = False
aider_coder = None
aider_io = None
aider_models = None

try:
    from aider.coders import Coder
    from aider.io import InputOutput
    from aider.models import Model
    aider_coder = Coder
    aider_io = InputOutput
    aider_models = Model
    AIDER_AVAILABLE = True
except ImportError:
    pass

# Register adapter status
from . import register_adapter
register_adapter("aider", AIDER_AVAILABLE, "0.83.1" if AIDER_AVAILABLE else None)


class EditFormat(Enum):
    """Aider edit formats for different use cases."""
    DIFF = "diff"              # Standard diff format
    WHOLE = "whole"            # Replace entire file
    ARCHITECT = "architect"    # Two-stage: plan then implement
    UDIFF = "udiff"            # Universal diff format


class AiderModel(Enum):
    """Pre-configured model aliases."""
    CLAUDE_SONNET = "sonnet"
    CLAUDE_OPUS = "opus"
    GPT_4O = "gpt-4o"
    GPT_4_TURBO = "gpt-4-turbo"
    DEEPSEEK = "deepseek"
    O3_MINI = "o3-mini"


@dataclass
class CodeChange:
    """Represents a single code change made by Aider."""
    file_path: str
    change_type: str  # "created", "modified", "deleted"
    diff: Optional[str] = None
    commit_hash: Optional[str] = None
    commit_message: Optional[str] = None


@dataclass
class CodingResult:
    """Result from an Aider coding session."""
    success: bool
    prompt: str
    changes: List[CodeChange] = field(default_factory=list)
    tokens_sent: int = 0
    tokens_received: int = 0
    cost: float = 0.0
    response: str = ""
    errors: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ArchitectPlan:
    """Plan generated by Aider's architect mode."""
    summary: str
    files_to_modify: List[str]
    files_to_create: List[str]
    implementation_steps: List[str]
    estimated_complexity: str  # "low", "medium", "high"


class AiderAdapter:
    """
    Adapter for Aider AI pair programming.

    Aider provides intelligent code editing capabilities including:
    - Natural language to code changes
    - Multi-file refactoring
    - Git-aware operations
    - Architect mode for complex tasks

    Reference: https://aider.chat/docs/
    """

    def __init__(
        self,
        model: Union[str, AiderModel] = AiderModel.CLAUDE_SONNET,
        api_key: Optional[str] = None,
        edit_format: EditFormat = EditFormat.DIFF,
        auto_commits: bool = False,
        use_git: bool = True,
    ):
        """
        Initialize Aider adapter.

        Args:
            model: LLM model to use (alias or full name)
            api_key: API key for model provider
            edit_format: How code changes are applied
            auto_commits: Automatically commit changes
            use_git: Enable git integration
        """
        self._available = AIDER_AVAILABLE
        self.model_name = model.value if isinstance(model, AiderModel) else model
        self.api_key = api_key
        self.edit_format = edit_format
        self.auto_commits = auto_commits
        self.use_git = use_git
        self._coder = None
        self._io = None

    def get_status(self) -> Dict[str, Any]:
        """Get adapter status."""
        return {
            "available": self._available,
            "model": self.model_name,
            "edit_format": self.edit_format.value,
            "auto_commits": self.auto_commits,
            "use_git": self.use_git,
            "configured": self._coder is not None,
        }

    def _check_available(self):
        """Check if Aider is available, raise error if not."""
        if not self._available:
            raise ImportError(
                "Aider is not installed. Install with: pip install aider-chat"
            )

    def _setup_api_key(self):
        """Set up the appropriate API key environment variable."""
        if not self.api_key:
            return

        # Determine provider from model name
        model_lower = self.model_name.lower()
        if any(x in model_lower for x in ["claude", "sonnet", "opus", "haiku"]):
            os.environ["ANTHROPIC_API_KEY"] = self.api_key
        elif any(x in model_lower for x in ["gpt", "o3", "o1"]):
            os.environ["OPENAI_API_KEY"] = self.api_key
        elif "deepseek" in model_lower:
            os.environ["DEEPSEEK_API_KEY"] = self.api_key

    def configure(
        self,
        working_directory: Optional[str] = None,
        editable_files: Optional[List[str]] = None,
        readonly_files: Optional[List[str]] = None,
        editor_model: Optional[str] = None,
    ) -> "AiderAdapter":
        """
        Configure Aider coder instance.

        Args:
            working_directory: Directory to operate in
            editable_files: Files that can be modified
            readonly_files: Files for context only (not modified)
            editor_model: Separate model for editing (architect mode)

        Returns:
            Self for chaining
        """
        self._check_available()
        self._setup_api_key()

        # Set working directory
        if working_directory:
            os.chdir(working_directory)

        # Configure I/O (non-interactive mode)
        self._io = aider_io(
            yes=True,  # Auto-accept changes
            pretty=False,
        )

        # Configure model
        if self.edit_format == EditFormat.ARCHITECT and editor_model:
            model = aider_models(
                model=self.model_name,
                editor_model=editor_model,
            )
            edit_fmt = "architect"
        else:
            model = aider_models(self.model_name)
            edit_fmt = self.edit_format.value

        # Create coder instance
        self._coder = aider_coder.create(
            main_model=model,
            edit_format=edit_fmt,
            io=self._io,
            fnames=editable_files or [],
            read_only_fnames=readonly_files or [],
            auto_commits=self.auto_commits,
            use_git=self.use_git,
        )

        return self

    def add_files(self, files: List[str], readonly: bool = False):
        """
        Add files to the coding context.

        Args:
            files: List of file paths to add
            readonly: If True, files are read-only context
        """
        self._check_available()

        if self._coder is None:
            raise RuntimeError("Coder not configured. Call configure() first.")

        for file_path in files:
            if readonly:
                self._coder.add_rel_fname(file_path, readonly=True)
            else:
                self._coder.add_rel_fname(file_path)

    async def code(
        self,
        prompt: str,
        files: Optional[List[str]] = None,
    ) -> CodingResult:
        """
        Execute a coding task with Aider.

        Args:
            prompt: Natural language description of the task
            files: Optional list of files to focus on

        Returns:
            CodingResult with changes and metadata
        """
        self._check_available()

        if self._coder is None:
            self.configure(editable_files=files or [])
        elif files:
            self.add_files(files)

        errors = []
        changes = []

        try:
            # Run the coding task
            self._coder.run(prompt)

            # Collect changes (if git enabled)
            if self.use_git and self._coder.last_aider_commit_hash:
                changes.append(CodeChange(
                    file_path="(multiple files)",
                    change_type="modified",
                    commit_hash=self._coder.last_aider_commit_hash,
                    commit_message=self._coder.last_aider_commit_message,
                ))

            return CodingResult(
                success=True,
                prompt=prompt,
                changes=changes,
                response=str(self._coder.partial_response_content or ""),
                metadata={
                    "model": self.model_name,
                    "edit_format": self.edit_format.value,
                },
            )

        except Exception as e:
            errors.append(str(e))
            return CodingResult(
                success=False,
                prompt=prompt,
                errors=errors,
                metadata={"model": self.model_name},
            )

    async def architect(
        self,
        task: str,
        files: List[str],
        editor_model: Optional[str] = None,
    ) -> CodingResult:
        """
        Use architect mode for complex refactoring.

        Architect mode uses a two-stage approach:
        1. Planning: Main model creates a detailed plan
        2. Implementation: Editor model executes the plan

        Args:
            task: Description of the refactoring task
            files: Files involved in the refactoring
            editor_model: Model for implementation (defaults to same)

        Returns:
            CodingResult with all changes
        """
        self._check_available()

        # Reconfigure for architect mode
        self.edit_format = EditFormat.ARCHITECT
        self.configure(
            editable_files=files,
            editor_model=editor_model or self.model_name,
        )

        return await self.code(task)

    async def explain(self, file_path: str, question: str) -> str:
        """
        Ask Aider to explain code.

        Args:
            file_path: Path to the file to explain
            question: Specific question about the code

        Returns:
            Explanation from Aider
        """
        self._check_available()

        if self._coder is None:
            self.configure(readonly_files=[file_path])
        else:
            self.add_files([file_path], readonly=True)

        prompt = f"Explain this code: {question}"
        self._coder.run(prompt)

        return str(self._coder.partial_response_content or "")

    async def refactor(
        self,
        files: List[str],
        refactor_type: str,
        description: Optional[str] = None,
    ) -> CodingResult:
        """
        Perform a specific refactoring operation.

        Args:
            files: Files to refactor
            refactor_type: Type of refactoring (e.g., "extract_function",
                          "rename", "simplify", "add_types")
            description: Additional context for the refactoring

        Returns:
            CodingResult with changes
        """
        refactor_prompts = {
            "extract_function": "Extract repeated code into well-named functions",
            "rename": "Rename variables and functions to be more descriptive",
            "simplify": "Simplify complex code while maintaining functionality",
            "add_types": "Add type hints to all functions and variables",
            "add_docstrings": "Add comprehensive docstrings to all functions and classes",
            "remove_dead_code": "Remove unused imports, variables, and functions",
            "improve_error_handling": "Add proper error handling and validation",
        }

        base_prompt = refactor_prompts.get(refactor_type, refactor_type)
        if description:
            base_prompt = f"{base_prompt}. {description}"

        return await self.code(base_prompt, files=files)


# Fallback implementation using subprocess
class AiderFallback:
    """
    Fallback implementation using Aider CLI.
    Used when the Python library isn't available but CLI is installed.
    """

    def __init__(
        self,
        model: str = "sonnet",
        auto_commits: bool = False,
    ):
        self.model = model
        self.auto_commits = auto_commits
        self._cli_available = self._check_cli()

    def _check_cli(self) -> bool:
        """Check if Aider CLI is available."""
        try:
            result = subprocess.run(
                ["aider", "--version"],
                capture_output=True,
                text=True,
            )
            return result.returncode == 0
        except FileNotFoundError:
            return False

    def get_status(self) -> Dict[str, Any]:
        """Get fallback adapter status."""
        return {
            "available": self._cli_available,
            "mode": "cli_fallback",
            "model": self.model,
        }

    async def code(
        self,
        prompt: str,
        files: Optional[List[str]] = None,
        working_directory: Optional[str] = None,
    ) -> CodingResult:
        """
        Execute coding task via CLI.

        Args:
            prompt: Natural language task description
            files: Files to include
            working_directory: Directory to operate in

        Returns:
            CodingResult with outcome
        """
        if not self._cli_available:
            return CodingResult(
                success=False,
                prompt=prompt,
                errors=["Aider CLI not installed. Install with: pip install aider-chat"],
            )

        cmd = ["aider", "--model", self.model, "--yes"]

        if not self.auto_commits:
            cmd.append("--no-auto-commits")

        if files:
            cmd.extend(files)

        cmd.extend(["--message", prompt])

        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                cwd=working_directory,
                timeout=300,  # 5 minute timeout
            )

            success = result.returncode == 0

            return CodingResult(
                success=success,
                prompt=prompt,
                response=result.stdout,
                errors=[result.stderr] if result.stderr and not success else [],
                metadata={"mode": "cli", "model": self.model},
            )

        except subprocess.TimeoutExpired:
            return CodingResult(
                success=False,
                prompt=prompt,
                errors=["Aider command timed out after 5 minutes"],
            )
        except Exception as e:
            return CodingResult(
                success=False,
                prompt=prompt,
                errors=[str(e)],
            )


def get_aider_adapter(**kwargs) -> Union[AiderAdapter, AiderFallback]:
    """
    Get appropriate Aider adapter based on availability.

    Returns:
        AiderAdapter if library available, AiderFallback otherwise
    """
    if AIDER_AVAILABLE:
        return AiderAdapter(**kwargs)
    return AiderFallback(**kwargs)
